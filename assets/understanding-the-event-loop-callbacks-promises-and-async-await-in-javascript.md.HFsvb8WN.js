import{_ as e,c as a,o as s,V as i}from"./chunks/framework.C80zbCY-.js";const m=JSON.parse('{"title":"Comprender Event Loop, Callbacks, Promises, y Async/Await en JavaScript","description":"","frontmatter":{},"headers":[],"relativePath":"understanding-the-event-loop-callbacks-promises-and-async-await-in-javascript.md","filePath":"understanding-the-event-loop-callbacks-promises-and-async-await-in-javascript.md"}'),n={name:"understanding-the-event-loop-callbacks-promises-and-async-await-in-javascript.md"},l=i(`<h1 id="comprender-event-loop-callbacks-promises-y-async-await-en-javascript" tabindex="-1">Comprender Event Loop, Callbacks, Promises, y Async/Await en JavaScript <a class="header-anchor" href="#comprender-event-loop-callbacks-promises-y-async-await-en-javascript" aria-label="Permalink to &quot;Comprender Event Loop, Callbacks, Promises, y Async/Await en JavaScript&quot;">​</a></h1><div class="info custom-block"><p class="custom-block-title">INFO</p><p>La fuente original (en ingles) de este tutorial se encuentra <a href="https://www.digitalocean.com/community/tutorials/understanding-the-event-loop-callbacks-promises-and-async-await-in-javascript" target="_blank" rel="noreferrer">aquí</a></p></div><h2 id="introduccion" tabindex="-1">Introducción <a class="header-anchor" href="#introduccion" aria-label="Permalink to &quot;Introducción&quot;">​</a></h2><p>En los primeros tiempos de Internet, los sitios web solían constar de datos estáticos en una <a href="https://www.digitalocean.com/community/tutorial-series/how-to-build-a-website-with-html" target="_blank" rel="noreferrer">página HTML</a>. Pero ahora que las aplicaciones web se han vuelto más interactivas y dinámicas, se ha vuelto cada vez más necesario realizar operaciones intensivas, como realizar solicitudes de red externas para recuperar datos de <a href="https://developer.mozilla.org/en-US/docs/Glossary/API" target="_blank" rel="noreferrer">API</a>. Para manejar estas operaciones en JavaScript, un desarrollador debe utilizar técnicas de <em>programación asincrónica</em>.</p><p>Dado que JavaScript es un lenguaje de programación <em>de un solo hilo</em> con un modelo de ejecución <em>sincrónica</em> que procesa una operación tras otra, solo puede procesar una instrucción a la vez. Sin embargo, una acción como solicitar datos de una API puede llevar una cantidad de tiempo indeterminada, según el tamaño de los datos solicitados, la velocidad de la conexión de red y otros factores. Si las llamadas a la API se realizaran de manera sincrónica, el navegador no podría manejar ninguna entrada del usuario, como desplazarse o hacer clic en un botón, hasta que se complete esa operación. Esto se conoce como <em>bloqueo</em>.</p><p>Para evitar el comportamiento de bloqueo, el entorno del navegador tiene muchas API web a las que JavaScript puede acceder que son <em>asincrónicas</em>, lo que significa que pueden ejecutarse en paralelo con otras operaciones en lugar de secuencialmente. Esto es útil porque permite al usuario continuar usando el navegador normalmente mientras se procesan las operaciones asincrónicas.</p><p>Como desarrollador de JavaScript, debe saber cómo trabajar con API web asincrónicas y manejar la respuesta o el error de esas operaciones. En este artículo, aprenderá sobre el bucle de eventos, la forma original de lidiar con el comportamiento asincrónico a través de devoluciones de llamadas, la incorporación actualizada de promesas en <a href="https://262.ecma-international.org/6.0/" target="_blank" rel="noreferrer">ECMAScript 2015</a> y la práctica moderna de usar <code>async/await</code>.</p><div class="info custom-block"><p class="custom-block-title">Nota</p><p>Este artículo se centra en JavaScript del lado del cliente en el entorno del navegador. Los mismos conceptos son generalmente válidos en el entorno de <a href="https://nodejs.org/en" target="_blank" rel="noreferrer">Node.js</a>, sin embargo, Node.js utiliza sus propias <a href="https://nodejs.org/api/" target="_blank" rel="noreferrer">C++ API</a> en lugar de las <a href="https://developer.mozilla.org/en-US/docs/Web/API" target="_blank" rel="noreferrer">Web API</a> del navegador. Para obtener más información sobre la programación asincrónica en Node.js, consulte <a href="https://www.digitalocean.com/community/tutorials/how-to-write-asynchronous-code-in-node-js" target="_blank" rel="noreferrer">Cómo Escribir Código Asincrónico en Node.js</a>.</p></div><h2 id="el-bucle-event" tabindex="-1">El Bucle Event <a class="header-anchor" href="#el-bucle-event" aria-label="Permalink to &quot;El Bucle Event&quot;">​</a></h2><p>En esta sección se explicará cómo JavaScript maneja el código asincrónico con el bucle de eventos. Primero se mostrará una demostración del bucle de eventos en funcionamiento y luego se explicarán los dos elementos del bucle de eventos: la pila y la cola.</p><p>El código JavaScript que no utiliza ninguna API web asincrónica se ejecutará de manera sincrónica, una a la vez, de manera secuencial. Esto se demuestra con este código de ejemplo que llama a tres funciones, cada una de las cuales imprime un número en la <a href="./how-to-use-the-js-dev-console.html">consola</a>:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Define three example functions</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> third</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>En este código, se definen tres funciones que imprimen números con <code>console.log()</code>.</p><p>A continuación, se escriben las llamadas a las funciones:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Execute the functions</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">third</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>La salida se basará en el orden en que se llamaron las funciones—<code>first()</code>, <code>second()</code> y luego <code>third()</code>:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Output</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">3</span></span></code></pre></div><p>Cuando se utiliza una API web asincrónica, las reglas se vuelven más complicadas. Una API integrada con la que puedes probar esto es <code>setTimeout</code>, que establece un temporizador y realiza una acción después de un período de tiempo específico. <code>setTimeout</code> debe ser asincrónico, de lo contrario, todo el navegador permanecería congelado durante la espera, lo que daría como resultado una mala experiencia de usuario.</p><p>Agrega <code>setTimeout</code> a la función <code>second</code> para simular una solicitud asincrónica:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Define three example functions, but one of them contains asynchronous code</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> third</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>setTimeout</code> toma dos argumentos: la función que se ejecutará de forma asincrónica y la cantidad de tiempo que esperará antes de llamar a esa función. En este código, envolviste <code>console.log</code> en una función anónima y la pasaste a <code>setTimeout</code>, luego configuraste la función para que se ejecute después de <code>0</code> milisegundos.</p><p>Ahora llama a las funciones, como lo hiciste antes:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Execute the functions</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">first</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">second</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">third</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>Se podría esperar que con un <code>setTimeout</code> establecido en <code>0</code>, la ejecución de estas tres funciones dé como resultado que los números se impriman en orden secuencial. Pero debido a que es asincrónico, la función con el tiempo de espera se imprimirá en último lugar:</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Output</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">2</span></span></code></pre></div><p>No habrá diferencia alguna si establece el tiempo de espera en cero segundos o cinco minutos—el <code>console.log</code> llamado por el código asincrónico se ejecutará después de las funciones de nivel superior sincrónicas. Esto sucede porque el entorno de host de JavaScript, en este caso el navegador, utiliza un concepto llamado <em>bucle de eventos</em> para manejar la concurrencia o eventos paralelos. Dado que JavaScript solo puede ejecutar una instrucción a la vez, necesita que el bucle de eventos esté informado de cuándo ejecutar qué instrucción específica. El bucle de eventos maneja esto con los conceptos de una <em>pila</em> y una <em>cola</em>.</p><h3 id="pila" tabindex="-1">Pila <a class="header-anchor" href="#pila" aria-label="Permalink to &quot;Pila&quot;">​</a></h3><p>La <em>pila</em>, o pila de llamadas, contiene el estado de la función que se está ejecutando en ese momento. Si no estás familiarizado con el concepto de pila, puedes imaginarla como una <a href="./understanding-arrays-in-javascript.html">matriz</a> con propiedades de último en entrar, primero en salir (LIFO, “Last in, first out”), lo que significa que solo puedes agregar o quitar elementos del final de la pila. JavaScript ejecutará el <em>marco</em> actual (o la llamada de función en un entorno específico) en la pila, luego lo eliminará y pasará al siguiente.</p><p>Para el ejemplo que solo contiene código sincrónico, el navegador maneja la ejecución en el siguiente orden:</p><ul><li>Agrega <code>first()</code> a la pila, ejecuta <code>first()</code> que registra <code>1</code> en la consola, elimina <code>first()</code> de la pila.</li><li>Agrega <code>second()</code> a la pila, ejecuta <code>second()</code> que registra <code>2</code> en la consola, elimina <code>second()</code> de la pila.</li><li>Agrega <code>third()</code> a la pila, ejecuta <code>third()</code> que registra <code>3</code> en la consola, elimina <code>third()</code> de la pila.</li></ul><p>El segundo ejemplo con <code>setTimeout</code> se ve así:</p><ul><li>Agrega <code>first()</code> a la pila, ejecuta <code>first()</code> que registra <code>1</code> en la consola, elimina <code>first()</code> de la pila.</li><li>Agrega <code>second()</code> a la pila, ejecuta <code>second()</code>. <ul><li>Agrega <code>setTimeout()</code> a la pila, ejecute la API Web <code>setTimeout()</code> que inicia un temporizador y agrega la función anónima a la cola, elimina <code>setTimeout()</code> de la pila.</li></ul></li><li>Elimina <code>second()</code> de la pila.</li><li>Agrega <code>third()</code> a la pila, ejecuta <code>third()</code> que registra <code>3</code> en la consola, elimina <code>third()</code> de la pila.</li><li>El bucle de eventos verifica la cola en busca de mensajes pendientes y encuentra la función anónima de <code>setTimeout()</code>, agrega la función a la pila que registra <code>2</code> en la consola y luego la elimina de la pila.</li></ul><p>El uso de <code>setTimeout</code>, una API Web asincrónica, presenta el concepto de cola, que este tutorial cubrirá a continuación.</p><h3 id="cola" tabindex="-1">Cola <a class="header-anchor" href="#cola" aria-label="Permalink to &quot;Cola&quot;">​</a></h3><p>La <em>cola</em>, también conocida como cola de mensajes o cola de tareas, es un área de espera para funciones. Siempre que la pila de llamadas esté vacía, el bucle de eventos comprobará la cola en busca de mensajes en espera, comenzando por el mensaje más antiguo. Una vez que encuentre uno, lo agregará a la pila, que ejecutará la función en el mensaje.</p><p>En el ejemplo <code>setTimeout</code>, la función anónima se ejecuta inmediatamente después del resto de la ejecución de nivel superior, ya que el temporizador se estableció en <code>0</code> segundos. Es importante recordar que el temporizador no significa que el código se ejecutará exactamente en <code>0</code> segundos o en el tiempo especificado, sino que agregará la función anónima a la cola en ese lapso de tiempo. Este sistema de cola existe porque si el temporizador agregara la función anónima directamente a la pila cuando finaliza, interrumpiría cualquier función que se esté ejecutando en ese momento, lo que podría tener efectos no deseados e impredecibles.</p><div class="info custom-block"><p class="custom-block-title">Nota</p><p>También hay otra cola llamada cola de trabajos o cola de microtareas que maneja promesas. Las microtareas como las promesas se manejan con mayor prioridad que las macrotareas como <code>setTimeout</code>.</p></div><p>Ahora ya sabe cómo el bucle de eventos utiliza la pila y la cola para manejar el orden de ejecución del código. La siguiente tarea es averiguar cómo controlar el orden de ejecución en su código. Para ello, primero aprenderá sobre la forma original de garantizar que el bucle de eventos maneje correctamente el código asincrónico: las funciones de devolución de llamada.</p><h2 id="callback-functions" tabindex="-1">Callback Functions <a class="header-anchor" href="#callback-functions" aria-label="Permalink to &quot;Callback Functions&quot;">​</a></h2>`,39),o=[l];function t(c,r,d,p,h,u){return s(),a("div",null,o)}const g=e(n,[["render",t]]);export{m as __pageData,g as default};
